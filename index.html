<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
  stroke: none;
}

.lines {
  stroke: #FFF;
  fill: none;
  stroke-width: 0.5px;
  stroke-opacity: 0.5;
}

circle {
  fill: #FFF;
  fill-opacity: 0.75;
  stroke-width: 0.5px;
  stroke: #000;
  stroke-opacity: 0.5;
}
.frame-offset-1 {
  fill: none;
  stroke-opacity: 0.5;
}
.frame-offset-2 {
  fill: none;
  stroke-opacity: 0.4;
}
.frame-offset-3 {
  fill: none;
  stroke-opacity: 0.2;
}
.frame-offset-4 {
  fill: none;
  stroke-opacity: 0.1;
}
</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script>


var HOST = 'http://saleiva.cartodb.com/api/v2/sql'
// var SQL = 'select ward, the_geom, array_agg(num_crimes) as values, array_agg(date) as dates from chicago_aggrday group by ward, the_geom'

var SQL = "SELECT array_agg(a.value) as values, array_agg(a.date) as dates, b.the_geom FROM idealista_districts_transposed a, madrid_distritos b WHERE a.distrito = lower(b.nombre02) GROUP BY a.distrito, b.the_geom"

var GEO = HOST + '?q=' + SQL + "&format=topojson"

var FRAME_TIME = 100;

var width = 960,
    height = 500;

var rateById = d3.map();

var projection = d3.geo.mercator()
    .scale(1)
    .translate([0, 0])

var path = d3.geo.path()
    .projection(projection);


var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var yearLabel = svg.append("text");

queue()
    .defer(d3.json, GEO)
    .await(ready);

function fitBounds(geojson, projection) {
  var b = path.bounds(geojson),
    s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
    t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];

  projection
    .scale(s)
    .translate(t);
}

var BUBBLES = true;
var BUBBLE_TRAILS = true;
var MIN_BUBBLE_SIZE = 4;
var MAX_BUBBLE_SIZE = 30;

function ready(error, geo) {

  var geojson = Object.keys(geo.objects).map(function(g) { return topojson.feature(geo, geo.objects[g]); });
  // create interpolation objects per feature
  // with dates and values  

  var maxValue = Number.MIN_VALUE;
  var minValue = Number.MAX_VALUE;
  var maxDate = Number.MIN_VALUE;
  var minDate = Number.MAX_VALUE;

  for(var i = 0; i < geojson.length; ++i) {
    var g = geojson[i];
    var dates = JSON.parse(
        g.properties.dates
          .replace('{', '[')
          .replace('}', ']')
        ).map(function(d) { return new Date(d.replace(/-/g, '/')); });

    g.properties.val = d3.time.scale().domain(dates).range(g.properties.values).clamp(true);

    var max = d3.max(g.properties.values);
    var min = d3.min(g.properties.values);
    maxValue =  max > maxValue ? max: maxValue;
    minValue =  min < minValue ? min: minValue;

    max = d3.max(dates);
    min = d3.min(dates);
    maxDate =  max > maxDate ? max: maxDate;
    minDate =  min < minDate ? min: minDate;

  }

  yearLabel
    .text('loading...')
    .attr("font-family", "sans-serif")
    .attr("font-size", "20px")
    .attr("x", 100)
    .attr("y", 100);

  geojson = { type: "FeatureCollection", features: geojson };

  // generate color scale based on max min values 
  var colorRange = s = d3.scale.linear()
      .domain([minValue, maxValue])
      .interpolate(d3.interpolateRgb)
      .range(["#FFFFB2", "#B10026"])

  var bubbleSize = d3.scale.linear()
      .domain([minValue, maxValue])
      .range([MIN_BUBBLE_SIZE, MAX_BUBBLE_SIZE])

  var dateScale = d3.time.scale().domain([minDate, maxDate])


  fitBounds(geojson, projection)

  var g = svg.append("g");

  function _update(time, dateTicks, currentTick) {
    var geoms = g.selectAll("path")
        .data(geojson.features)

    geoms.enter().append("path")
        .attr('fill', function(d) { 
          return colorRange(d.properties.val(time));
        })
        .attr("d", path)

    geoms.enter().append("path")
      .attr("class", "lines")
      .attr("d", path);

    geoms.transition().duration(FRAME_TIME).attr('fill', function(d) { 
      return colorRange(d.properties.val(time));
    })

    yearLabel.text(time.getFullYear());

    //
    // bubbles
    //
    if(BUBBLES) {
      function addBubbles(data, _class, time) {
        var bubble = g.selectAll("circle." + _class)
            .data(geojson.features)
        var circle = d3.svg.symbol().type('circle')

        bubble.enter()
          .append("circle")
          .attr('class', _class)
          .attr("r", function(d) { return bubbleSize(d.properties.val(time)); })
          .attr({
            cx: function(d) { 
              return path.centroid(d)[0]; 
            },
            cy: function(d) { return path.centroid(d)[1]; }
          })

        bubble.attr("r", function(d) { return bubbleSize(d.properties.val(time)); })
      }
      addBubbles(geojson.features, 'frame-offset-0', time);
      if (BUBBLE_TRAILS) {
        addBubbles(geojson.features, 'frame-offset-1', dateTicks[currentTick - 1]);
        addBubbles(geojson.features, 'frame-offset-2', dateTicks[currentTick - 2]);
        addBubbles(geojson.features, 'frame-offset-3', dateTicks[currentTick - 3]);
        addBubbles(geojson.features, 'frame-offset-4', dateTicks[currentTick - 4]);
      }
    }

  }

  var c = 0;
  var NUM_TICKS = 51;
  function tick() {
    var dateTicks = dateScale.ticks(NUM_TICKS);
    var time = dateTicks[c];
    _update(time, dateTicks, c);
    c = (c + 1) % NUM_TICKS;
  }
  tick();
  setInterval(tick, FRAME_TIME);
}

</script>
